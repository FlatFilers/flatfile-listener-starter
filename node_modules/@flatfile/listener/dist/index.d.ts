import { DefaultApi, Event } from '@flatfile/api';

declare class AuthenticatedClient {
    private _api?;
    get api(): DefaultApi;
    private _fetch?;
    fetch(url: string): any;
}

declare class FlatfileEvent extends AuthenticatedClient {
    private readonly src;
    /**
     * Event ID from the API
     *
     * @example us0_ev_82hgidh9skd
     * @readonly
     *
     */
    readonly id?: string;
    /**
     * Topic the event was produced on
     *
     * @example workbook:created
     * @readonly
     */
    readonly topic: string;
    readonly domain: string;
    readonly target: string;
    readonly action: string;
    readonly context: any;
    readonly payload: any;
    constructor(src: Event);
    /**
     * Should return either event body if expanded already or fetch data from the
     * signed callback URL
     *
     * @todo this should work with the included callback URL
     */
    get data(): Promise<any>;
}
type EventCallback = (evt: FlatfileEvent) => void;

/**
 * EventHandler is a Flatfile flavored implementation of EventTarget
 */
declare class EventHandler extends AuthenticatedClient {
    /**
     * Apply a filter to the values of an event
     */
    readonly filterQuery?: EventFilter;
    /**
     * Cache of registered listeners on this instance
     * @private
     */
    private listeners;
    constructor(filter?: EventFilter);
    /**
     * Cache of registered child nodes for this listener. These nodes will
     * only receive events that pass the parent filter.
     *
     * @private
     */
    private nodes;
    /**
     * Register a subscriber for events that match this path
     */
    on(query: Arrayable<string>, callback: EventCallback): this;
    on(query: Arrayable<string>, filter: EventFilter, callback: EventCallback): this;
    /**
     * Add child nodes to send this event to as well
     *
     * @param node
     */
    addNode(node: EventHandler): this;
    /**
     * Dispatch an event and resolve the promise once it has completed (or
     * errored
     *
     * @todo - is there a right order in which to resolve event listeners?
     *   Should it matter?
     *
     * @param event
     */
    dispatchEvent(event: FlatfileEvent | Event | any): Promise<void>;
    /**
     * @deprecated legacy shim for receiving events from the VM layer
     * @alias dispatchEvent
     * @param event
     */
    routeEvent(event: Event): Promise<void>;
    /**
     * Actually trigger the event listeners on this particular target
     *
     * @note It is safer for now to run this in series to avoid IO locks and
     *       potential race conditions and uncaught errors
     *
     * @param event
     */
    trigger(event: FlatfileEvent): Promise<void>;
    /**
     * Get any listeners from this target subscribing to this event
     *
     * @param event
     */
    getListeners(event: FlatfileEvent): EventCallback[];
    /**
     * Attach more event listeners using a callback function. Used most
     * frequently for plugins.
     *
     * @param fn
     */
    use(fn: (handler: this) => void): this;
    /**
     * Filter an event out based on glob filter object
     *
     * @param event
     * @param filter
     */
    matchEvent(event: FlatfileEvent, filter: EventFilter | undefined): boolean;
}
type EventFilter = Record<string, Arrayable<string>>;
type Arrayable<T> = T | Array<T>;

declare abstract class EventDriver {
    _handler?: EventHandler;
    get handler(): EventHandler;
    /**
     * Mount an event handler
     *
     * @param handler
     */
    mountEventHandler(handler: EventHandler): this;
    /**
     * Dispatch an event
     *
     * @param e
     */
    dispatchEvent(e: any): this;
}

/**
 * The Client
 *
 * The Flatfile PubSub Client is just a simple event subscriber. It can
 * receive events from any PubSub driver. The default drivers are:
 *
 * - Webhook    (for simply processing events sent to URL)
 * - Websocket  (for subscribing real time on an HTTP2 connection)
 * - Serverless (for stateless invocations via AWS Lambda or similar)
 *
 * Once an event is received, it is routed to any awaiting listeners which
 * are added with `addEventListener()` or its alias `on()`.
 *
 * Flatfile events follow a standard structure and event listeners can use
 * any of the following syntaxes to react to events within Flatfile.
 *
 * // listen to an event
 * addEventListener('entity:topic')
 *
 * // listen to an event on a specific namespace
 * addEventListener('entity:topic@namespace')
 *
 * // listen to a specific context on a namespace
 * addEventListener('entity:topic@namespace?context=us_sp_89234oihsdo')
 *
 * // filter by any
 * addEventListener('entity:topic@namespace?')
 *
 */

declare class Client extends EventHandler {
    /**
     * Subscribe to events only within a certain namespace.
     *
     * @param namespace
     * @param cb
     */
    namespace(namespace: string | string[], cb?: SubFn): Client;
    /**
     * Filter by namespace
     *
     * @param filter
     * @param cb
     */
    filter(filter: EventFilter, cb?: SubFn): Client;
    setupFunctions: Array<(...args: any[]) => void>;
    beforeMount(cb: SubFn): void;
    /**
     * Start subscribing to events
     *
     * @param cb
     */
    static create(cb: SubFn): Client;
    /**
     * Mount this client using an acceptable Event Driver
     */
    mount(driver: EventDriver): this;
}
type SubFn = (client: Client) => void;

declare class PollingEventDriver extends EventDriver {
    private options;
    constructor(options: {
        interval: number;
        environmentId: string;
    });
    start(): void;
    shutdown(): void;
}

/**
 * Flatfile's Virtual Machine is stateless / serverless. So when a new event
 * is handled, it will just call `handle(event)`.
 */
declare class FlatfileVirtualMachine extends EventDriver {
    /**
     * This method is triggered from within the Flatfile Core VM Runner. This
     * EventDriver does not have to listen for events because this method will
     * be invoked as necessary.
     *
     * @param event
     */
    handle(event: FlatfileEvent): void;
}

export { Arrayable, AuthenticatedClient, Client, EventCallback, EventFilter, EventHandler, FlatfileEvent, FlatfileVirtualMachine, PollingEventDriver };
